{"version":"1","records":[{"hierarchy":{"lvl1":"ARM Field Site Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"ARM Field Site Cookbook"},"content":"\n\n\n\n\n\n\n\n\n\nThis Project Pythia Cookbook covers how to work with ARM Field Campaign datasets, leveraging previous training and outreach event materials.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Motivation"},"type":"lvl2","url":"/#motivation","position":2},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Motivation"},"content":"We consolidate computational workflow training materials from previous summer school and workshop events. There is a foundations section which details the core open-source tools, and a projects section showcasing previous students’ workflows with the associated citation information.","type":"content","url":"/#motivation","position":3},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":4},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Authors"},"content":"Max Grover","type":"content","url":"/#authors","position":5},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":6},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":7},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":8},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Structure"},"content":"","type":"content","url":"/#structure","position":9},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Foundations","lvl2":"Structure"},"type":"lvl3","url":"/#foundations","position":10},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Foundations","lvl2":"Structure"},"content":"This section is dedicated to the core open-source tools which are used in the associated projects. We also include data access information in this section.","type":"content","url":"/#foundations","position":11},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Projects","lvl2":"Structure"},"type":"lvl3","url":"/#projects","position":12},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Projects","lvl2":"Structure"},"content":"Project notebooks from previous training events are included in this section. We apply additional cleaning and reproducibility work that could not be finalized during the week-long events.","type":"content","url":"/#projects","position":13},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":14},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder or on your local machine.","type":"content","url":"/#running-the-notebooks","position":15},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":16},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\n“launch Binder”. After a moment you should be presented with a\nnotebook that you can interact with. I.e. you’ll be able to execute\nand even change the example programs. You’ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.\n\nNote, not all Cookbook chapters are executable. If you do not see\nthe rocket ship icon, such as on this page, you are not viewing an\nexecutable book chapter.","type":"content","url":"/#running-on-binder","position":17},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":18},{"hierarchy":{"lvl1":"ARM Field Site Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your computer, you will need to follow this workflow:\n\n(Replace “cookbook-example” with the title of your cookbooks)\n\nClone the https://github.com/mgrover1/arm-field-site-cookbook repository: git clone https://github.com/mgrover1/arm-field-site-cookbook.git\n\nMove into the arm-field-site-cookbook directorycd arm-field-site-cookbook\n\nCreate and activate your conda environment from the environment.yml fileconda env create -f environment.yml\nconda activate arm-field-site-cookbook-dev\n\nMove into the foundations directory and start up Jupyterlabcd foundations\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":19},{"hierarchy":{"lvl1":"Radar Data with Py-ART"},"type":"lvl1","url":"/foundations/pyart/readme","position":0},{"hierarchy":{"lvl1":"Radar Data with Py-ART"},"content":"Within this section, we cover working with weather radar data using the Python ARM Radar Toolkit (Py-ART)","type":"content","url":"/foundations/pyart/readme","position":1},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar"},"type":"lvl1","url":"/foundations/pyart/pyart-basics","position":0},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-basics","position":1},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar"},"type":"lvl1","url":"/foundations/pyart/pyart-basics#py-art-basics-with-xradar","position":2},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-basics#py-art-basics-with-xradar","position":3},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Overview"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#overview","position":4},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Overview"},"content":"Within this notebook, we will cover:\n\nGeneral overview of Py-ART and its functionality\n\nReading data using Py-ART\n\nAn overview of the pyart.Radar object\n\nCreate a Plot of our Radar Data\n\n","type":"content","url":"/foundations/pyart/pyart-basics#overview","position":5},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Prerequisites"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#prerequisites","position":6},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nIntro to Cartopy\n\nHelpful\n\nBasic features\n\nWeather Radar Basics\n\nHelpful\n\nBackground Information\n\nMatplotlib Basics\n\nHelpful\n\nBasic plotting\n\nNumPy Basics\n\nHelpful\n\nBasic arrays\n\nXarray Basics\n\nHelpful\n\nMulti-dimensional arrays\n\nTime to learn: 45 minutes\n\n","type":"content","url":"/foundations/pyart/pyart-basics#prerequisites","position":7},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Imports"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#imports","position":8},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Imports"},"content":"\n\nimport os\nimport warnings\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\n\n\nimport pyart\nfrom pyart.testing import get_test_data\nimport xradar as xd\n\nwarnings.filterwarnings(\"ignore\")\n\n","type":"content","url":"/foundations/pyart/pyart-basics#imports","position":9},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"An Overview of Py-ART"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#an-overview-of-py-art","position":10},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"An Overview of Py-ART"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-basics#an-overview-of-py-art","position":11},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"History of the Py-ART","lvl2":"An Overview of Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#history-of-the-py-art","position":12},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"History of the Py-ART","lvl2":"An Overview of Py-ART"},"content":"Development began to address the needs of ARM with the acquisition of a number of\nnew scanning cloud and precipitation radar as part of the American Recovery Act.\n\nThe project has since expanded to work with a variety of weather radars and a wider user\nbase including radar researchers and climate modelers.\n\nThe software has been released on GitHub as open source software under a BSD license.\nRuns on Linux, OS X. It also runs on Windows with more limited functionality.","type":"content","url":"/foundations/pyart/pyart-basics#history-of-the-py-art","position":13},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"What can Py-ART Do?","lvl2":"An Overview of Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#what-can-py-art-do","position":14},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"What can Py-ART Do?","lvl2":"An Overview of Py-ART"},"content":"Py-ART can be used for a variety of tasks from basic plotting to more complex\nprocessing pipelines. Specific uses for Py-ART include:\n\npyart.io Module for reading radar data in a variety of file formats.\n\npyart.graph Module for creating plots and visualization of radar data.\n\npyart.correct Module for correcting radar moments while in antenna coordinates, such as:\n\nDoppler unfolding/de-aliasing.\n\nAttenuation correction.\n\nPhase processing using a Linear Programming method.\n\npyart.map Mapping data from one or multiple radars onto a Cartesian grid.\n\npyart.retrieve Performing retrievals.\n\npyart​.io​.write​_cfradial Writing radial and Cartesian data to NetCDF files.","type":"content","url":"/foundations/pyart/pyart-basics#what-can-py-art-do","position":15},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Py-ART 2.0","lvl2":"An Overview of Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#py-art-2-0","position":16},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Py-ART 2.0","lvl2":"An Overview of Py-ART"},"content":"Py-ART 2.0 offers the option to use \n\nxradar for reading weather radar data into the xarray data model. Py-ART 2.0 also supports \n\ncmweather, a new package dedicated to supporting color vision deficiency (CVD) friendly colormaps. Please check the \n\nlinked documentation to view all the changes within Py-ART 2.0.\n\n","type":"content","url":"/foundations/pyart/pyart-basics#py-art-2-0","position":17},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Reading in Data Using Py-ART and xradar"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#reading-in-data-using-py-art-and-xradar","position":18},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Reading in Data Using Py-ART and xradar"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-basics#reading-in-data-using-py-art-and-xradar","position":19},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Reading data in using xradar.io.open_","lvl2":"Reading in Data Using Py-ART and xradar"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#reading-data-in-using-xradar-io-open","position":20},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Reading data in using xradar.io.open_","lvl2":"Reading in Data Using Py-ART and xradar"},"content":"\n\nWhen reading in a radar file, we use the xradar.io module.\n\nxradar.io can read a variety of different radar formats, such as Cf/Radial, ODIM_H5, etc.\nThe documentation on what formats can be read by xradar can be found here:\n\nxradar readers Documentation\n\nLet’s take a look at one of these readers:\n\n?xd.io.open_cfradial1_datatree\n\nLet’s use a sample data file from pyart - which is \n\ncfradial format.\n\nWhen we read this in, we get a \n\nxarray.DataTree object that bundles the different radar sweeps into one structure!\n\nfile = \"/data/project/ARM_Summer_School_2025/radar/csapr2/ppi/bnfcsapr2cfrS3.a1.20250315.190050.nc\"\ndt = xd.io.open_cfradial1_datatree(file)\ndt\n\n","type":"content","url":"/foundations/pyart/pyart-basics#reading-data-in-using-xradar-io-open","position":21},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Investigate the xradar object","lvl2":"Reading in Data Using Py-ART and xradar"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#investigate-the-xradar-object","position":22},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Investigate the xradar object","lvl2":"Reading in Data Using Py-ART and xradar"},"content":"\n\nWithin this \n\nxradar object object are the actual data fields, each stored in a different group, mimicking the FM301/cfradial2 data standard.\n\nThis is where data such as reflectivity and velocity are stored.\n\nTo see what fields are present we can add the fields and keys additions to the variable where the radar object is stored.\n\ndt[\"sweep_0\"]\n\n","type":"content","url":"/foundations/pyart/pyart-basics#investigate-the-xradar-object","position":23},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Extract a sample data field","lvl3":"Investigate the xradar object","lvl2":"Reading in Data Using Py-ART and xradar"},"type":"lvl4","url":"/foundations/pyart/pyart-basics#extract-a-sample-data-field","position":24},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Extract a sample data field","lvl3":"Investigate the xradar object","lvl2":"Reading in Data Using Py-ART and xradar"},"content":"\n\nThe fields are stored in a dictionary, each containing coordinates, units and more.\nAll can be accessed by just adding the fields addition to the radar object variable.\n\nFor an individual field, we add a string in brackets after the fields addition to see\nthe contents of that field.\n\nLet’s take a look at 'corrected_reflectivity_horizontal', which is a common field to investigate.\n\nprint(dt[\"sweep_0\"][\"uncorrected_reflectivity_h\"])\n\nWe can go even further in the dictionary and access the actual reflectivity data.\n\nWe use add .data at the end, which will extract the data array (which is a numpy array) from the dictionary.\n\nreflectivity = dt[\"sweep_0\"][\"uncorrected_reflectivity_h\"].data\nprint(type(reflectivity), reflectivity)\n\nLets’ check the size of this array...\n\nreflectivity.shape\n\nThis reflectivity data array, numpy array, is a two-dimensional array with dimensions:\n\nRange (distance away from the radar)\n\nAzimuth (direction around the radar)\n\ndt[\"sweep_0\"].dims\n\nIf we wanted to look the 300th ray, at the second gate, we would use something like the following:\n\nprint(reflectivity[300, 2])\n\nWe can also select a specific azimuth if desired, using the xarray syntax:\n\ndt[\"sweep_0\"].sel(azimuth=180, method=\"nearest\")\n\n\n\n","type":"content","url":"/foundations/pyart/pyart-basics#extract-a-sample-data-field","position":25},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Plotting our Radar Data"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#plotting-our-radar-data","position":26},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Plotting our Radar Data"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-basics#plotting-our-radar-data","position":27},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"An Overview of Py-ART Plotting Utilities","lvl2":"Plotting our Radar Data"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#an-overview-of-py-art-plotting-utilities","position":28},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"An Overview of Py-ART Plotting Utilities","lvl2":"Plotting our Radar Data"},"content":"Now that we have loaded the data and inspected it, the next logical thing to do is to visualize the data! Py-ART’s visualization functionality is done through the objects in the \n\npyart.graph module.\n\nIn Py-ART there are 4 primary visualization classes in pyart.graph:\n\nRadarDisplay\n\nRadarMapDisplay\n\nAirborneRadarDisplay\n\nPlotting grid data\n\nGridMapDisplay","type":"content","url":"/foundations/pyart/pyart-basics#an-overview-of-py-art-plotting-utilities","position":29},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Use the RadarMapDisplay with our data","lvl2":"Plotting our Radar Data"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#use-the-radarmapdisplay-with-our-data","position":30},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Use the RadarMapDisplay with our data","lvl2":"Plotting our Radar Data"},"content":"For the this example, we will be using RadarMapDisplay, using Cartopy to deal with geographic coordinates.\n\nWe start by creating a figure first, and adding our traditional radar methods to the xradar object.\n\nfig = plt.figure(figsize=[10, 10])\nradar = pyart.xradar.Xradar(dt)\n\nOnce we have a figure, let’s add our RadarMapDisplay\n\nfig = plt.figure(figsize=[10, 10])\ndisplay = pyart.graph.RadarMapDisplay(radar)\n\nAdding our map display without specifying a field to plot won’t do anything we need to specifically add a field to field using .plot_ppi_map()\n\ndisplay.plot_ppi_map(\"uncorrected_reflectivity_h\")\n\nBy default, it will plot the elevation scan, the the default colormap from Matplotlib... let’s customize!\n\nWe add the following arguements:\n\nsweep=3 - The fourth elevation scan (since we are using Python indexing)\n\nvmin=-20 - Minimum value for our plotted field/colorbar\n\nvmax=60 - Maximum value for our plotted field/colorbar\n\nprojection=ccrs.PlateCarree() - Cartopy latitude/longitude coordinate system\n\ncmap='pyart_HomeyerRainbow' - Colormap to use, selecting one provided by PyART\n\nfig = plt.figure(figsize=[12, 12])\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map(\n    \"uncorrected_reflectivity_h\",\n    sweep=3,\n    vmin=-20,\n    vmax=60,\n    projection=ccrs.PlateCarree(),\n    cmap=\"HomeyerRainbow\",\n)\nplt.show()\n\nYou can change many parameters in the graph by changing the arguments to plot_ppi_map. As you can recall from earlier. simply view these arguments in a Jupyter notebook by typing:\n\n?display.plot_ppi_map\n\nOr, let’s view a different elevation scan! To do this, change the sweep parameter in the plot_ppi_map function.\n\nfig = plt.figure(figsize=[12, 12])\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map(\n    \"uncorrected_reflectivity_h\",\n    sweep=0,\n    vmin=-20,\n    vmax=60,\n    projection=ccrs.PlateCarree(),\n    cmap=\"Carbone42\",\n)\nplt.show()\n\n\n\n","type":"content","url":"/foundations/pyart/pyart-basics#use-the-radarmapdisplay-with-our-data","position":31},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Gridding with Py-ART"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#gridding-with-py-art","position":32},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Gridding with Py-ART"},"content":"Gridding is an important workflow to understand when working with radar data! Here, we walk through the steps required.\n\n","type":"content","url":"/foundations/pyart/pyart-basics#gridding-with-py-art","position":33},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Antenna vs. Cartesian Coordinates","lvl2":"Gridding with Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#antenna-vs-cartesian-coordinates","position":34},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Antenna vs. Cartesian Coordinates","lvl2":"Gridding with Py-ART"},"content":"Radar data, by default, is stored in a polar (or antenna) coordinate system, with the data coordinates stored as an angle (ranging from 0 to 360 degrees with 0 == North), and a radius from the radar, and an elevation which is the angle between the ground and the ground.\n\nThis format can be challenging to plot, since it is scan/radar specific. Also, it can make comparing with model data, which is on a lat/lon grid, challenging since one would need to transform the model daa cartesian coordinates to polar/antenna coordiantes.\n\nFortunately, PyART has a variety of gridding routines, which can be used to grid your data to a Cartesian grid. Once it is in this new grid, one can easily slice/dice the dataset, and compare to other data sources.","type":"content","url":"/foundations/pyart/pyart-basics#antenna-vs-cartesian-coordinates","position":35},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Why is Gridding Important?","lvl2":"Gridding with Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#why-is-gridding-important","position":36},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Why is Gridding Important?","lvl2":"Gridding with Py-ART"},"content":"Gridding is essential to combining multiple data sources (ex. multiple radars), and comparing to other data sources (ex. model data). There are also decisions that are made during the gridding process that have a large impact on the regridded data - for example:\n\nWhat resolution should my grid be?\n\nWhich interpolation routine should I use?\n\nHow smooth should my interpolated data be?\n\nWhile there is not always a right or wrong answer, it is important to understand the options available, and document which routine you used with your data! Also - experiment with different options and choose the best for your use case!","type":"content","url":"/foundations/pyart/pyart-basics#why-is-gridding-important","position":37},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"The Grid Object","lvl2":"Gridding with Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#the-grid-object","position":38},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"The Grid Object","lvl2":"Gridding with Py-ART"},"content":"We can transform our data into this grid object, from the radars, using pyart.map.grid_from_radars().\n\nBeforing gridding our data, we need to make a decision about the desired grid resolution and extent. For example, one might imagine a grid configuration of:\n\nGrid extent/limits\n\n20 km in the x-direction (north/south)\n\n20 km in the y-direction (west/east)\n\n15 km in the z-direction (vertical)\n\n500 m spatial resolution\n\nThe pyart.map.grid_from_radars() function takes the grid shape and grid limits as input, with the order (z, y, x).\n\nLet’s setup our configuration, setting our grid extent first, with the distance measured in meters\n\nz_grid_limits = (500.,15_000.)\ny_grid_limits = (-30_000.,30_000.)\nx_grid_limits = (-30_000.,30_000.)\n\nNow that we have our grid limits, we can set our desired resolution (again, in meters)\n\ngrid_resolution = 500\n\nLet’s compute our grid shape - using the extent and resolution to compute the number of grid points in each direction.\n\ndef compute_number_of_points(extent, resolution):\n    return int((extent[1] - extent[0])/resolution)\n\nNow that we have a helper function to compute this, let’s apply it to our vertical dimension\n\nz_grid_points = compute_number_of_points(z_grid_limits, grid_resolution)\nz_grid_points\n\nWe can apply this to the horizontal (x, y) dimensions as well.\n\nx_grid_points = compute_number_of_points(x_grid_limits, grid_resolution)\ny_grid_points = compute_number_of_points(y_grid_limits, grid_resolution)\n\nprint(z_grid_points,\n      y_grid_points,\n      x_grid_points)\n\n","type":"content","url":"/foundations/pyart/pyart-basics#the-grid-object","position":39},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Use our configuration to grid the data!","lvl3":"The Grid Object","lvl2":"Gridding with Py-ART"},"type":"lvl4","url":"/foundations/pyart/pyart-basics#use-our-configuration-to-grid-the-data","position":40},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Use our configuration to grid the data!","lvl3":"The Grid Object","lvl2":"Gridding with Py-ART"},"content":"Now that we have the grid shape and grid limits, let’s grid up our radar!\n\ngrid = pyart.map.grid_from_radars([radar],\n                                  grid_shape=(z_grid_points,\n                                              y_grid_points,\n                                              x_grid_points),\n                                  grid_limits=(z_grid_limits,\n                                               y_grid_limits,\n                                               x_grid_limits),\n                                 )\ngrid\n\n","type":"content","url":"/foundations/pyart/pyart-basics#use-our-configuration-to-grid-the-data","position":41},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#plot-the-grid-object","position":42},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"content":"","type":"content","url":"/foundations/pyart/pyart-basics#plot-the-grid-object","position":43},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Plot a horizontal view of the data","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"type":"lvl4","url":"/foundations/pyart/pyart-basics#plot-a-horizontal-view-of-the-data","position":44},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Plot a horizontal view of the data","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"content":"We can use the GridMapDisplay from pyart.graph to visualize our regridded data, starting with a horizontal view (slice along a single vertical level)\n\ndisplay = pyart.graph.GridMapDisplay(grid)\ndisplay.plot_grid('uncorrected_reflectivity_h',\n                  level=0,\n                  vmin=-20,\n                  vmax=60,\n                  cmap='HomeyerRainbow')\n\n","type":"content","url":"/foundations/pyart/pyart-basics#plot-a-horizontal-view-of-the-data","position":45},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Plot a Latitudinal Slice","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"type":"lvl4","url":"/foundations/pyart/pyart-basics#plot-a-latitudinal-slice","position":46},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Plot a Latitudinal Slice","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"content":"\n\nWe can also slice through a single latitude or longitude!\n\ndisplay.plot_latitude_slice('uncorrected_reflectivity_h',\n                            lat=36.5,\n                            vmin=-20,\n                            vmax=60,\n                            cmap='HomeyerRainbow')\nplt.xlim([-20, 20]);\n\n","type":"content","url":"/foundations/pyart/pyart-basics#plot-a-latitudinal-slice","position":47},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Plot with Xarray","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"type":"lvl4","url":"/foundations/pyart/pyart-basics#plot-with-xarray","position":48},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl4":"Plot with Xarray","lvl3":"Plot the Grid Object","lvl2":"Gridding with Py-ART"},"content":"\n\nAnother neat feature of the Grid object is that we can transform it to an xarray.Dataset!\n\nds = grid.to_xarray()\nds\n\nNow, our plotting routine is a one-liner, starting with the horizontal slice:\n\nds.isel(z=0).uncorrected_reflectivity_h.plot(cmap='HomeyerRainbow',\n                                             vmin=-20,\n                                             vmax=60);\n\nAnd a vertical slice at a given y dimension (latitude)\n\nds.sel(y=1300,\n       method='nearest').uncorrected_reflectivity_h.plot(cmap='HomeyerRainbow',\n                                                         vmin=-20,\n                                                         vmax=60);\n\n","type":"content","url":"/foundations/pyart/pyart-basics#plot-with-xarray","position":49},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Challenge"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#challenge","position":50},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Challenge"},"content":"Find data from last night’s event and plot it up! Feel free to grid, etc.\n\nHint: the site code is bnf with the instrument being csapr2\n\nhttps://adc.arm.gov\n\n","type":"content","url":"/foundations/pyart/pyart-basics#challenge","position":51},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Summary"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#summary","position":52},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Summary"},"content":"Within this notebook, we covered the basics of working with radar data using pyart, including:\n\nReading in a file using xradar.io\n\nInvestigating the xradar object\n\nVisualizing radar data using the RadarMapDisplay\n\nGridding with Py-ART\n\nVisualizing gridded output","type":"content","url":"/foundations/pyart/pyart-basics#summary","position":53},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"What’s Next","lvl2":"Summary"},"type":"lvl3","url":"/foundations/pyart/pyart-basics#whats-next","position":54},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl3":"What’s Next","lvl2":"Summary"},"content":"In the next few notebooks, we walk through applying data cleaning methods, and advanced visualization methods!\n\n","type":"content","url":"/foundations/pyart/pyart-basics#whats-next","position":55},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Resources and References"},"type":"lvl2","url":"/foundations/pyart/pyart-basics#resources-and-references","position":56},{"hierarchy":{"lvl1":"Py-ART Basics with Xradar","lvl2":"Resources and References"},"content":"Py-ART essentials links:\n\nLanding page\n\nExamples\n\nSource Code\n\nMailing list\n\nIssue Tracker","type":"content","url":"/foundations/pyart/pyart-basics#resources-and-references","position":57},{"hierarchy":{"lvl1":"Py-ART Corrections"},"type":"lvl1","url":"/foundations/pyart/pyart-corrections","position":0},{"hierarchy":{"lvl1":"Py-ART Corrections"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-corrections","position":1},{"hierarchy":{"lvl1":"Py-ART Corrections"},"type":"lvl1","url":"/foundations/pyart/pyart-corrections#py-art-corrections","position":2},{"hierarchy":{"lvl1":"Py-ART Corrections"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#py-art-corrections","position":3},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Overview"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#overview","position":4},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Overview"},"content":"Within this notebook, we will cover:\n\nIntro to radar aliasing.\n\nCalculation of velocity texture using Py-ART\n\nDealiasing the velocity field","type":"content","url":"/foundations/pyart/pyart-corrections#overview","position":5},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Prerequisites"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#prerequisites","position":6},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nPy-ART Basics\n\nHelpful\n\nBasic features\n\nWeather Radar Basics\n\nHelpful\n\nBackground Information\n\nMatplotlib Basics\n\nHelpful\n\nBasic plotting\n\nNumPy Basics\n\nHelpful\n\nBasic arrays\n\nXarray Basics\n\nHelpful\n\nMulti-dimensional arrays\n\nTime to learn: 15 minutes\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#prerequisites","position":7},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Imports"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#imports","position":8},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Imports"},"content":"\n\nimport os\nimport warnings\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\n\nimport pyart\nfrom pyart.testing import get_test_data\nimport xradar as xd\n\nwarnings.filterwarnings('ignore')\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#imports","position":9},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Read in the Data"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#read-in-the-data","position":10},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Read in the Data"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#read-in-the-data","position":11},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Read in a sample file from the University of Alabama Huntsville (UAH) ARMOR Site","lvl2":"Read in the Data"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#read-in-a-sample-file-from-the-university-of-alabama-huntsville-uah-armor-site","position":12},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Read in a sample file from the University of Alabama Huntsville (UAH) ARMOR Site","lvl2":"Read in the Data"},"content":"Our data is formatted as an sigmet file, which is a vendor-specific format, produced by Vaisala radars.\n\nInspect the xradar.io documentation for the iris/sigment reader for this specific format\n\nfile = \"../../data/uah-armor/RAW_NA_000_125_20080411182229\"\n\nradar = pyart.io.read(file)\n\nradar.fields\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#read-in-a-sample-file-from-the-university-of-alabama-huntsville-uah-armor-site","position":13},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Plot a quick-look of reflectivity and velocity","lvl2":"Read in the Data"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#plot-a-quick-look-of-reflectivity-and-velocity","position":14},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Plot a quick-look of reflectivity and velocity","lvl2":"Read in the Data"},"content":"We can start by taking a quick look at the reflectivity and velocity fields. Notice how the velocity field is rather messy, indicated by the speckles and high/low values directly next to each other\n\nfig = plt.figure(figsize=[8, 10])\nax = plt.subplot(211, projection=ccrs.PlateCarree())\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('reflectivity',\n                     ax=ax,\n                     sweep=0,\n                     resolution='50m',\n                     vmin=0,\n                     vmax=60, \n                     projection=ccrs.PlateCarree(),\n                     cmap='HomeyerRainbow')\n\nax2 = plt.subplot(2,1,2,projection=ccrs.PlateCarree())\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('velocity',\n                     ax=ax2,\n                     sweep=0,\n                     resolution='50m',\n                     vmin=-17,\n                     vmax=17, \n                     projection=ccrs.PlateCarree(),\n                     cmap='balance')\nplt.show()\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#plot-a-quick-look-of-reflectivity-and-velocity","position":15},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Dealiasing our Velocity"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#dealiasing-our-velocity","position":16},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Dealiasing our Velocity"},"content":"","type":"content","url":"/foundations/pyart/pyart-corrections#dealiasing-our-velocity","position":17},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"An Overview of Aliasing","lvl2":"Dealiasing our Velocity"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#an-overview-of-aliasing","position":18},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"An Overview of Aliasing","lvl2":"Dealiasing our Velocity"},"content":"\n\nThe radial velocity measured by the radar is mesasured by detecting the phase shift between the transmitted pulse and the pulse recieved by the radar. However, using this methodology, it is only possible to detect phase shifts within \\pm 2\\pi due to the periodicity of the transmitted wave. Therefore, for example, a phase shift of 3\\pi would erroneously be detected as a phase shift of -\\pi and give an incorrect value of velocity when retrieved by the radar. This phenomena is called aliasing. The maximium unambious velocity that can be detected by the radar before aliasing occurs is called the Nyquist velocity.\n\nIn the next example, you will see an example of aliasing occurring, where the values of +15 m/s abruptly transition into a region of -15 m/s, with -5 m/s in the middle of the region around 37 N, 97 W.\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#an-overview-of-aliasing","position":19},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Calculate Velocity Texture","lvl2":"Dealiasing our Velocity"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#calculate-velocity-texture","position":20},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Calculate Velocity Texture","lvl2":"Dealiasing our Velocity"},"content":"First, for dealiasing to work efficiently, we need to use a GateFilter. Notice that, this time, the data shown does not give us a nice gate_id. This is what raw data looks like, and we need to do some preprocessing on the data to remove noise and clutter. Thankfully, Py-ART gives us the capability to do this. As a simple filter in this example, we will first calculate the velocity texture using Py-ART’s \n\ncalculate_velocity_texture function. The velocity texture is the standard deviation of velocity surrounding a gate. This will be higher in the presence of noise.\n\nLet’s investigate this function first...\n\npyart.retrieve.calculate_velocity_texture?\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#calculate-velocity-texture","position":21},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Determining the Right Parameters","lvl2":"Dealiasing our Velocity"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#determining-the-right-parameters","position":22},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Determining the Right Parameters","lvl2":"Dealiasing our Velocity"},"content":"You’ll notice that we need:\n\nOur radar object\n\nThe name of our velocity field\n\nThe number of gates within our window to use to calculate the texture\n\nThe nyquist velocity\n\nWe can retrieve the nyquest velocity from our instrument parameters fortunately - using the following syntax!\n\nnyquist_velocity = radar.instrument_parameters[\"nyquist_velocity\"][\"data\"]\nnyquist_velocity\n\nWhile the nyquist velocity is stored as an array, we see that these are all the same value...\n\nnp.unique(nyquist_velocity)\n\nLet’s save this single value to a float to use later...\n\nnyquist_value = np.unique(nyquist_velocity)[0]\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#determining-the-right-parameters","position":23},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#calculate-velocity-texture-and-filter-our-data","position":24},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"content":"Now that we have an ide?a of which parameters to pass in, let’s calculate velocity texture!\n\nvel_texture = pyart.retrieve.calculate_velocity_texture(radar,\n                                                        vel_field='velocity',\n                                                        nyq=nyquist_value)\nvel_texture\n\nThe pyart.retrieve.calculate_velocity_texture function results in a data dictionary, including the actual data, as well as metadata. We can add this to our radar object, by using the radar.add_field method, passing the name of our new field (\"texture\"), the data dictionary (vel_texture), and a clarification that we want to replace the existing velocity texture field if it already exists in our radar object (replace_existing=True)\n\nradar.add_field('texture', vel_texture, replace_existing=True)\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#calculate-velocity-texture-and-filter-our-data","position":25},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Plot our Velocity Texture Field","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"type":"lvl4","url":"/foundations/pyart/pyart-corrections#plot-our-velocity-texture-field","position":26},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Plot our Velocity Texture Field","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"content":"\n\nNow that we have our velocity texture field added to our radar object, let’s plot it!\n\nfig = plt.figure(figsize=[8, 8])\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('texture',\n                     sweep=0,\n                     resolution='50m',\n                     vmin=0,\n                     vmax=10, \n                     projection=ccrs.PlateCarree(),\n                     cmap='balance')\nplt.show()\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#plot-our-velocity-texture-field","position":27},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Determine a Suitable Velocity Texture Threshold","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"type":"lvl4","url":"/foundations/pyart/pyart-corrections#determine-a-suitable-velocity-texture-threshold","position":28},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Determine a Suitable Velocity Texture Threshold","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"content":"\n\nPlot a histogram of velocity texture to get a better idea of what values correspond to hydrometeors and what values of texture correspond to artifacts.\n\nIn the below example, a threshold of 3 would eliminate most of the peak corresponding to noise around 6 while preserving most of the values in the peak of ~0.5 corresponding to hydrometeors.\n\nhist, bins = np.histogram(radar.fields['texture']['data'],\n                          bins=150)\nbins = (bins[1:]+bins[:-1])/2.0\n\nplt.plot(bins,\n         hist,\n         label='Velocity Texture Frequency')\nplt.axvline(3,\n            color='r',\n            label='Proposed Velocity Texture Threshold')\n\nplt.xlabel('Velocity texture')\nplt.ylabel('Count')\nplt.legend()\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#determine-a-suitable-velocity-texture-threshold","position":29},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Setup a Gatefilter Object and Apply our Threshold","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"type":"lvl4","url":"/foundations/pyart/pyart-corrections#setup-a-gatefilter-object-and-apply-our-threshold","position":30},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Setup a Gatefilter Object and Apply our Threshold","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"content":"\n\nNow we can set up our GateFilter (\n\npyart.filters.GateFilter), which allows us to easily apply masks and filters to our radar object.\n\ngatefilter = pyart.filters.GateFilter(radar)\ngatefilter\n\nWe discovered that a velocity texture threshold of only including values below 3 would be suitable for this dataset, we use the .exclude_above method, specifying we want to exclude texture values above 3.\n\ngatefilter.exclude_above('texture', 3)\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#setup-a-gatefilter-object-and-apply-our-threshold","position":31},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Plot our Filtered Data","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"type":"lvl4","url":"/foundations/pyart/pyart-corrections#plot-our-filtered-data","position":32},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Plot our Filtered Data","lvl3":"Calculate Velocity Texture and Filter our Data","lvl2":"Dealiasing our Velocity"},"content":"\n\nNow that we have created a gatefilter, filtering our data using the velocity texture, let’s plot our data!\n\nWe need to pass our gatefilter to the plot_ppi_map to apply it to our plot.\n\n# Plot our Unfiltered Data\nfig = plt.figure(figsize=[8, 10])\nax = plt.subplot(211, projection=ccrs.PlateCarree())\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('velocity',\n                     title='Raw Radial Velocity (no filter)',\n                     ax=ax,\n                     sweep=0,\n                     resolution='50m',\n                     vmin=-17,\n                     vmax=17,\n                     projection=ccrs.PlateCarree(),\n                     colorbar_label='Radial Velocity (m/s)',\n                     cmap='balance')\n\nax2 = plt.subplot(2,1,2,projection=ccrs.PlateCarree())\n\n# Plot our filtered data\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('velocity',\n                     title='Radial Velocity with Velocity Texture Filter',\n                     ax=ax2,\n                     sweep=0,\n                     resolution='50m',\n                     vmin=-17,\n                     vmax=17, \n                     projection=ccrs.PlateCarree(),\n                     colorbar_label='Radial Velocity (m/s)',\n                     gatefilter=gatefilter,\n                     cmap='balance')\nplt.show()\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#plot-our-filtered-data","position":33},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Dealias the Velocity Using the Region-Based Method","lvl2":"Dealiasing our Velocity"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#dealias-the-velocity-using-the-region-based-method","position":34},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"Dealias the Velocity Using the Region-Based Method","lvl2":"Dealiasing our Velocity"},"content":"\n\nAt this point, we can use the \n\ndealias_region_based to dealias the velocities and then add the new field to the radar!\n\nvelocity_dealiased = pyart.correct.dealias_region_based(radar,\n                                                        vel_field='velocity',\n                                                        nyquist_vel=nyquist_value,\n                                                        centered=True,\n                                                        gatefilter=gatefilter)\n\n# Add our data dictionary to the radar object\nradar.add_field('corrected_velocity', velocity_dealiased, replace_existing=True)\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#dealias-the-velocity-using-the-region-based-method","position":35},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Plot our Cleaned, Dealiased Velocities","lvl3":"Dealias the Velocity Using the Region-Based Method","lvl2":"Dealiasing our Velocity"},"type":"lvl4","url":"/foundations/pyart/pyart-corrections#plot-our-cleaned-dealiased-velocities","position":36},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl4":"Plot our Cleaned, Dealiased Velocities","lvl3":"Dealias the Velocity Using the Region-Based Method","lvl2":"Dealiasing our Velocity"},"content":"\n\nPlot the new velocities, which now look much more realistic.\n\nfig = plt.figure(figsize=[8, 8])\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('corrected_velocity',\n                     sweep=0,\n                     resolution='50m',\n                     vmin=-30,\n                     vmax=30, \n                     projection=ccrs.PlateCarree(),\n                     colorbar_label='Radial Velocity (m/s)',\n                     cmap='balance',\n                     gatefilter=gatefilter)\nplt.show()\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#plot-our-cleaned-dealiased-velocities","position":37},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Compare our Raw Velocity Field to our Dealiased, Cleaned Velocity Field"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#compare-our-raw-velocity-field-to-our-dealiased-cleaned-velocity-field","position":38},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Compare our Raw Velocity Field to our Dealiased, Cleaned Velocity Field"},"content":"As a last comparison, let’s compare our raw, uncorrected velocities with our cleaned velocities, after applying the velocity texture threshold and dealiasing algorithm\n\n# Plot our Unfiltered Data\nfig = plt.figure(figsize=[8, 10])\nax = plt.subplot(211, projection=ccrs.PlateCarree())\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('velocity',\n                     title='Raw Radial Velocity (no filter)',\n                     ax=ax,\n                     sweep=0,\n                     resolution='50m',\n                     vmin=-30,\n                     vmax=30,\n                     projection=ccrs.PlateCarree(),\n                     colorbar_label='Radial Velocity (m/s)',\n                     cmap='balance')\n\nax2 = plt.subplot(2,1,2,projection=ccrs.PlateCarree())\n\n# Plot our filtered, dealiased data\ndisplay = pyart.graph.RadarMapDisplay(radar)\ndisplay.plot_ppi_map('corrected_velocity',\n                     title='Radial Velocity with Velocity Texture Filter and Dealiasing',\n                     ax=ax2,\n                     sweep=0,\n                     resolution='50m',\n                     vmin=-30,\n                     vmax=30, \n                     projection=ccrs.PlateCarree(),\n                     gatefilter=gatefilter,\n                     colorbar_label='Radial Velocity (m/s)',\n                     cmap='balance')\nplt.show()\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#compare-our-raw-velocity-field-to-our-dealiased-cleaned-velocity-field","position":39},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Conclusions"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#conclusions","position":40},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Conclusions"},"content":"Within this lesson, we walked through how to apply radial velocity corrections to a dataset, filtering based on the velocity texture and using a regional dealiasing algorithm.","type":"content","url":"/foundations/pyart/pyart-corrections#conclusions","position":41},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"What’s Next","lvl2":"Conclusions"},"type":"lvl3","url":"/foundations/pyart/pyart-corrections#whats-next","position":42},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl3":"What’s Next","lvl2":"Conclusions"},"content":"In the next few notebooks, we walk through retrieval development and advanced visualization methods!\n\n","type":"content","url":"/foundations/pyart/pyart-corrections#whats-next","position":43},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Resources and References"},"type":"lvl2","url":"/foundations/pyart/pyart-corrections#resources-and-references","position":44},{"hierarchy":{"lvl1":"Py-ART Corrections","lvl2":"Resources and References"},"content":"Py-ART essentials links:\n\nLanding page\n\nExamples\n\nSource Code\n\nMailing list\n\nIssue Tracker","type":"content","url":"/foundations/pyart/pyart-corrections#resources-and-references","position":45},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART"},"type":"lvl1","url":"/foundations/pyart/pyart-qpe","position":0},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-qpe","position":1},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART"},"type":"lvl1","url":"/foundations/pyart/pyart-qpe#quantitative-precipitation-estimate-qpe-analysis-with-py-art","position":2},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART"},"content":"\n\n","type":"content","url":"/foundations/pyart/pyart-qpe#quantitative-precipitation-estimate-qpe-analysis-with-py-art","position":3},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Overview"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#overview","position":4},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Overview"},"content":"Within this notebook, we will cover:\n\nCalculation of QPE from various radar fields\n\nGenearting a gridded QPE product\n\nComparison against operational models (MRMS)","type":"content","url":"/foundations/pyart/pyart-qpe#overview","position":5},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Prerequisites"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#prerequisites","position":6},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nPy-ART Basics\n\nHelpful\n\nBasic features\n\nWeather Radar Basics\n\nHelpful\n\nBackground Information\n\nMatplotlib Basics\n\nHelpful\n\nBasic plotting\n\nNumPy Basics\n\nHelpful\n\nBasic arrays\n\nXarray Basics\n\nHelpful\n\nMulti-dimensional arrays\n\nTime to learn: 15 minutes\n\n","type":"content","url":"/foundations/pyart/pyart-qpe#prerequisites","position":7},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Imports"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#imports","position":8},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Imports"},"content":"\n\nimport os\nimport warnings\nimport glob\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\n\nimport pyart\nfrom pyart.testing import get_test_data\nimport xradar as xd\n\nwarnings.filterwarnings('ignore')\n\n","type":"content","url":"/foundations/pyart/pyart-qpe#imports","position":9},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Investigate the Available Data"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#investigate-the-available-data","position":10},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Investigate the Available Data"},"content":"\n\nfile_list = sorted(glob.glob(\"/data/project/ARM_Summer_School_2025/radar/csapr2/ppi/*20250519*\"))\nfile_list\n\ndt = xd.io.open_cfradial1_datatree(file_list[0])\ndt\n\nradar = pyart.xradar.Xradar(dt)\ndisplay = pyart.graph.RadarDisplay(radar)\n\nradar\n\n# Generate matplotlib figure and axe array objects\nfig, axarr = plt.subplots(2, 2, figsize=[20, 12])\nplt.subplots_adjust(hspace=0.35)\n\n# reflectivity\ndisplay.plot('reflectivity', sweep=0, ax=axarr[0, 0], cmap='ChaseSpectral')\n\n# differential reflectivity\ndisplay.plot(\"differential_reflectivity\", sweep=0, ax=axarr[0, 1], cmap=\"RdBu_r\", vmin=-2, vmax=2)\n\n# doppler velocity\ndisplay.plot(\"mean_doppler_velocity\", sweep=0, ax=axarr[1, 0], cmap=\"RdBu_r\", vmin=-16, vmax=16)\n\n# differential phase\ndisplay.plot(\"specific_differential_phase\", sweep=0, ax=axarr[1, 1], cmap=\"ChaseSpectral\")\n\n","type":"content","url":"/foundations/pyart/pyart-qpe#investigate-the-available-data","position":11},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"QPE Functions"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#qpe-functions","position":12},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"QPE Functions"},"content":"\n\ndef reflectivity_rain(radar, refl=\"reflectivity\", alpha=0.0376, beta=0.6112):\n    \"\"\"\n    Function to calculate rainfall rates from radar reflectivity factor\n\n    Inputs\n    ------\n    radar : Py-ART Radar Object\n        Py-ART radar object to extract reflectivity field from\n    refl : str\n        Specific name of reflectivity field within radar object\n    alpha : float\n        fit parameter\n    beta : float\n        fit parameter\n\n    Outputs\n    -------\n    radar : Py-ART Radar Object\n        Py-ART radar object with rainfall estimate from reflectivity included\n    \"\"\"\n    # define a gatefilter to apply the relationship to\n    gatefilter_z = pyart.correct.GateFilter(radar)\n    gatefilter_z.exclude_above(refl, 35)\n    # Apply the gatefilter to the rain rate\n    masked_z = np.ma.masked_array(radar.fields[refl]['data'], mask=gatefilter_z.gate_excluded) \n    # Apply the R(Z) relationship\n    rr_data = alpha * np.ma.power(np.ma.power(10.0, 0.1 * masked_z), beta)\n    # define the dictionary structure for the rain rate data\n    rain = pyart.config.get_metadata(\"radar_estimated_rain_rate\")\n    rain[\"long_name\"] = \"R(Z) Radar Estimated Rain Rate\"\n    rain[\"standard_name\"] = \"R(Z) Radar Estimated Rain Rate\"\n    rain[\"data\"] = rr_data\n    # add the field back into the radar object\n    radar.add_field(\"rain_z\", rain)\n\n    return radar\n\ndef kdp_rain(radar, phase=\"specific_differential_phase\", alpha=25.1, beta=0.777):\n    \"\"\"\n    Function to calculate rainfall rates from specific differential phase\n    Inputs\n    ------\n    radar : Py-ART Radar Object\n        Py-ART radar object to extract reflectivity field from\n    refl : str\n        Specific name of reflectivity field within radar object\n    alpha : float\n        fit parameter\n    beta : float\n        fit parameter\n\n    Outputs\n    -------\n    radar : Py-ART Radar Object\n        Py-ART radar object with rainfall estimate from reflectivity included\n    \"\"\"\n    # define a gatefilter to apply the relationship to\n    gatefilter_kdp = pyart.correct.GateFilter(radar)\n    gatefilter_kdp.exclude_below('reflectivity', 35)\n    # Apply the gatefilter to the rain rate\n    masked_z = np.ma.masked_array(radar.fields[phase]['data'], mask=gatefilter_kdp.gate_excluded) \n    # define the reflectivity data\n    reflect = radar.fields[phase][\"data\"]\n    rr_data = alpha * np.ma.power(np.ma.power(10.0, 0.1 * masked_z), beta)\n    # define the dictionary structure for the rain rate data\n    rain = pyart.config.get_metadata(\"radar_estimated_rain_rate\")\n    rain[\"long_name\"] = \"R(KDP) Radar Estimated Rain Rate\"\n    rain[\"standard_name\"] = \"R(KDP) Radar Estimated Rain Rate\"\n    rain[\"data\"] = rr_data\n    # add the field back into the radar object\n    radar.add_field(\"rain_kdp\", rain)\n\n    return radar\n\n# Apply the Radar estimated rain rates \nradar = reflectivity_rain(radar)\nradar = kdp_rain(radar)\nradar[\"sweep_1\"]\n\ndisplay = pyart.graph.RadarDisplay(radar)\n# Generate matplotlib figure and axe array objects\nfig, axarr = plt.subplots(1, 2, figsize=[14, 5])\nplt.subplots_adjust(wspace=0.2, hspace=0.35)\n\n# reflectivity\ndisplay.plot('rain_z', sweep=0, ax=axarr[0], cmap='ChaseSpectral')\n\n# differential reflectivity\ndisplay.plot(\"rain_kdp\", sweep=0, ax=axarr[1], cmap=\"RdBu_r\")\n\n","type":"content","url":"/foundations/pyart/pyart-qpe#qpe-functions","position":13},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Combined Radar Estimated Rainfall Product"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#combined-radar-estimated-rainfall-product","position":14},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Combined Radar Estimated Rainfall Product"},"content":"\n\nradar.fields[\"rain_z\"][\"data\"].mask\n\ncombined_data = np.where(~radar.fields[\"rain_z\"][\"data\"].mask, radar.fields[\"rain_z\"][\"data\"], radar.fields[\"rain_kdp\"][\"data\"])\n# Combine the masks using logical OR (mask where either is masked)\ncombined_mask = np.ma.mask_or(radar.fields[\"rain_z\"][\"data\"].mask, radar.fields[\"rain_kdp\"][\"data\"].mask)\n\n# Merge data and apply the combined mask\nmerged = np.ma.array(combined_data, mask=combined_mask)\n\ncombined_data\n\n# define the dictionary structure for the rain rate data\nrain = pyart.config.get_metadata(\"radar_estimated_rain_rate\")\nrain[\"long_name\"] = \"R(Z+KDP) Radar Estimated Rain Rate\"\nrain[\"standard_name\"] = \"R(Z+KDP) Radar Estimated Rain Rate\"\nrain[\"data\"] = combined_data\n# add the field back into the radar object\nradar.add_field(\"rain_combined\", rain)\n\ndisplay = pyart.graph.RadarDisplay(radar)\n# Generate matplotlib figure and axe array objects\nfig, axarr = plt.subplots(1, 2, figsize=[14, 5])\nplt.subplots_adjust(wspace=0.2, hspace=0.35)\n\n# reflectivity\ndisplay.plot('rain_combined', sweep=0, ax=axarr[0], cmap='ChaseSpectral', vmax=10)\n# reflectivity\ndisplay.plot('reflectivity', sweep=0, ax=axarr[1], cmap='ChaseSpectral')\n\n","type":"content","url":"/foundations/pyart/pyart-qpe#combined-radar-estimated-rainfall-product","position":15},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Create a Gridded QPE Product for Future Comparison with Model/MRMS"},"type":"lvl2","url":"/foundations/pyart/pyart-qpe#create-a-gridded-qpe-product-for-future-comparison-with-model-mrms","position":16},{"hierarchy":{"lvl1":"Quantitative Precipitation Estimate (QPE) Analysis with Py-ART","lvl2":"Create a Gridded QPE Product for Future Comparison with Model/MRMS"},"content":"\n\ndef bnf_grid(radar, \n             z_limits=(250., 15_000.), \n             y_limits=(-30_000., 30_000), \n             x_limits=(-30_000., 30_000),\n             resolution=250\n):\n    \"\"\"\n    Function to create a Py-ART grid object from a given radar file\n\n    Inputs\n    ------\n    radar : Py-ART radar object\n        Py-ART radar object to create a grid object from\n    z_limits : tuple\n        vertical dimension grid limits\n    y_limits : tuple\n        longitude dimension grid limits\n    x_limits : tuple\n        latitude dimension grid limits\n    resolution : float\n        desired resolution of our grid object\n\n    Calls\n    -----\n    compute_number_of_points\n        compute number of gates in each direction\n\n    Outputs\n    -------\n    grid : Py-ART Grid object\n    \"\"\"\n    def compute_number_of_points(extent, resolution):\n        return int((extent[1] - extent[0])/resolution)\n\n    z_grid_points = compute_number_of_points(z_limits, resolution)\n    x_grid_points = compute_number_of_points(x_limits, resolution)\n    y_grid_points = compute_number_of_points(y_limits, resolution)\n\n    grid = pyart.map.grid_from_radars([radar],\n                                      grid_shape=(z_grid_points,\n                                                  y_grid_points,\n                                                  x_grid_points),\n                                      grid_limits=(z_grid_limits,\n                                                   y_grid_limits,\n                                                   x_grid_limits),\n    )\n\n    return grid\n\ngrid = bnf_grid(radar)\n\ndisplay = pyart.graph.GridMapDisplay(grid)\ndisplay.plot_grid('rain_combined',\n                  level=1,\n                  vmin=0.1,\n                  vmax=15,\n                  cmap='HomeyerRainbow')","type":"content","url":"/foundations/pyart/pyart-qpe#create-a-gridded-qpe-product-for-future-comparison-with-model-mrms","position":17},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM"},"type":"lvl1","url":"/foundations/pyart/radars-with-arm","position":0},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM"},"content":"\n\n","type":"content","url":"/foundations/pyart/radars-with-arm","position":1},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM"},"type":"lvl1","url":"/foundations/pyart/radars-with-arm#introduction-to-radar-meteorology-with-arm","position":2},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM"},"content":"\n\n","type":"content","url":"/foundations/pyart/radars-with-arm#introduction-to-radar-meteorology-with-arm","position":3},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Overview"},"type":"lvl2","url":"/foundations/pyart/radars-with-arm#overview","position":4},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Overview"},"content":"Within this notebook, we will cover:\n\nGeneral structure of radar data\n\nRadar Scanning\n\nLook at various ARM radars\n\nDo a simple analysis\n\n","type":"content","url":"/foundations/pyart/radars-with-arm#overview","position":5},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Prerequisites"},"type":"lvl2","url":"/foundations/pyart/radars-with-arm#prerequisites","position":6},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nIntro to Cartopy\n\nHelpful\n\nBasic features\n\nMatplotlib Basics\n\nHelpful\n\nBasic plotting\n\nNumPy Basics\n\nHelpful\n\nBasic arrays\n\nTime to learn: 45 minutes\n\nimport os\nimport warnings\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\n\nimport matplotlib.pyplot as plt\n\nimport pyart\nfrom pyart.testing import get_test_data\nimport xradar as xd\nimport numpy as np\n\nwarnings.filterwarnings(\"ignore\")\n\nWe will use Py-ART to investigate data. This is not a Py-ART tutorial. Also this notebook is limited to moment data and will not cover lower level data such as doppler spectra.\n\n","type":"content","url":"/foundations/pyart/radars-with-arm#prerequisites","position":7},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"ARM Radars"},"type":"lvl2","url":"/foundations/pyart/radars-with-arm#arm-radars","position":8},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"ARM Radars"},"content":"\n\nARM’s main radars can be broken down into two categories: Scanning and zenith pointing. ARM operates radars at four requency bands: W, Ka, X and C band. ARM denotes radars as either cloud or precipitation sensing. W and Ka are only denoted as cloud sensing, X is both and C is only precipitation sensing. The radars are the Marine W-Band ARM Cloud Radar (M-WACR), Ka band Zenith Radar (Ka-ZR), Ka band ARM Scanning Cloud Radar (Ka-SACR), X band Scanning ARM Radar (X-SACR), X band Scanning ARM Precipition Radar (X-SAPR) and C band Scanning ARM Precipitation Radar (C-SAPR). The notation pertain more to the operation and suitability of the radar (eg there is nothing stopping a user using KAZR to study Precipitation).\n\n\n\nBNF has a C-SAPR, X-SACR, Ka-SACR and a KaZR. Why the different wavelengths? it all comes down to sensitivity, backscatter cross section and if the scattering is in the Reighley regieme where the size of the drops are much smaller than the wavelenth.\n\n\n\nThe sensitivity gains come from the beam with can be approximated as \\theta\\approx 1.22 \\frac{\\lambda}{D}\\quad(\\text{considering that}\\,\\sin\\theta\\approx\\theta). Bigger antenna smaller angle. Shorter wavelength smaller angle. And a smaller angle means you can squeeze more power into a volume.\n\nThe power recieved by a radar can be written as:\n\nP_r = \\frac{\\pi^3 c}{1024 \\ln(2)} \\cdot \\frac{P_t G^2 \\theta^2 h |\\kappa|^2 Z}{\\lambda^2 r^2}\n\nThis can be broken down to components intrinsic to the radar and the medium:\n\nP_r = \\underbrace{\\frac{P_t G^2 \\lambda^2 c \\tau}{(4\\pi)^3}}_{\\text{Radar}} \\underbrace{\\frac{\\pi^5 |K|^2}{\\lambda^4} \\frac{1}{R^2} \\sum D_i^6}_{\\text{Hydrometeors}}\n\nThe last component, the sum over all distribited scatters is, as described in the previous talk one of the basic measures from a radar is reflectivity factor:\n\nZ = \\int_{0}^{Dmax} N D^6\\mathrm{d}D \n\nAs long as D < \\lambda reflectivity factor is wavelength invariant.\n\n","type":"content","url":"/foundations/pyart/radars-with-arm#arm-radars","position":9},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Lets dig into some data to give some examples:"},"type":"lvl2","url":"/foundations/pyart/radars-with-arm#lets-dig-into-some-data-to-give-some-examples","position":10},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Lets dig into some data to give some examples:"},"content":"\n\nkazr = pyart.io.read('bnfkazr2cfrgeM1.a1.20250422.040000.nc')\n\ncsapr.metadata['doi']\n\nhttps://​www​.osti​.gov​/dataexplorer​/biblio​/dataset​/1467901​-band​-scanning​-arm​-precipitation​-radar​-generation\n\nBharadwaj, Nitin, Collis, Scott, Hardin, Joseph, Isom, Bradley, Lindenmaier, Iosif, Matthews, Alyssa, Nelson, Danny, Feng, Ya-Chien, Rocque, Marquette, Wendler, Tim, and Castro, Vagner. C-Band Scanning ARM Precipitation Radar, 2nd Generation. United States: N. p., 2021. Web. doi:10.5439/1467901.\n\nkazr.info()\n\nkazr.fields['reflectivity']\n\nLets make a plot of the data. Nothing fancy here:\n\nplt.pcolormesh(kazr.fields['reflectivity']['data'])\nplt.colorbar()\n\nLets make it nicer!\n\nmy_favorite_colormap = pyart.graph.cmweather.cm_colorblind.ChaseSpectral\nplt.pcolormesh(kazr.fields['reflectivity']['data'].transpose(), cmap=my_favorite_colormap)\nplt.colorbar()\n\nBeing a vertical pointing radar the geometry is simple, a time height cross section.\n\nLets look at a scanning radar, a Ka band scanning cloud radar.\n\nkasacr = pyart.io.read('bnfkasacrcfrS4.a1.20250422.040001.nc')\n\nplt.pcolormesh(kasacr.fields['reflectivity']['data'].transpose(), cmap=my_favorite_colormap)\nplt.colorbar()\n\nok! This is a little more complex! Here the antenna is moving. Lets look at the geometry.\n\n#Lets look at Azimuth\nplt.plot(kasacr.azimuth['data'])\n\nplt.plot(kasacr.elevation['data'])\n\nmyd = pyart.graph.RadarDisplay(kasacr)\nmyd.plot_ppi('reflectivity', cmap=my_favorite_colormap)\n\n","type":"content","url":"/foundations/pyart/radars-with-arm#lets-dig-into-some-data-to-give-some-examples","position":11},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Now lets look at C-SAPR"},"type":"lvl2","url":"/foundations/pyart/radars-with-arm#now-lets-look-at-c-sapr","position":12},{"hierarchy":{"lvl1":"Introduction to Radar Meteorology with ARM","lvl2":"Now lets look at C-SAPR"},"content":"\n\ncsapr = pyart.io.read('bnfcsapr2cfrS3.a1.20250422.040012.nc')\n\nplt.plot(csapr.azimuth['data'])\n\nmydc = pyart.graph.RadarDisplay(csapr)\nmydc.plot_ppi('reflectivity', cmap=my_favorite_colormap)\n\nalt = kazr.gate_z['data']\ndbz = kazr.fields['reflectivity']['data']\n\nfreq, height_edges, field_edges = np.histogram2d(\n        alt.data.flatten(),\n        dbz.data.flatten(), \n        bins = [np.linspace(0,15000,99), np.linspace(-60., 20., 79)])\n      \n\nX, Y = np.meshgrid(height_edges, field_edges)\nplt.pcolormesh(Y, X, freq.transpose(), cmap=my_favorite_colormap)\nplt.colorbar()\n\n\nalt = csapr.gate_z['data']\ndbz = csapr.fields['reflectivity']['data']\nfreq, height_edges, field_edges = np.histogram2d(\n        alt.data.flatten(),\n        dbz.data.flatten(), \n        bins = [np.linspace(0,15000,99), np.linspace(-40., 40., 79)])\n\nX, Y = np.meshgrid(height_edges, field_edges)\nplt.pcolormesh(Y, X, freq.transpose(), cmap=my_favorite_colormap)\nplt.colorbar()\n\n\nalt = kasacr.gate_z['data']\ndbz = kasacr.fields['reflectivity']['data']\nfreq, height_edges, field_edges = np.histogram2d(\n        alt.data.flatten(),\n        dbz.data.flatten(), \n        bins = [np.linspace(0,2000,39), np.linspace(-40., 40., 39)])\n\nX, Y = np.meshgrid(height_edges, field_edges)\nplt.pcolormesh(Y, X, freq.transpose(), cmap=my_favorite_colormap)\nplt.colorbar()\n\n\nNumber one rule of reflectivity club: Do math in linear units!\n\nAs an example lets look at rainfall retrievals. One of the simplest way of doing a rainfall retrieval is to use a simple power law rainfall relation or, “Z R relation” of the form Z=aR^b. So R=(Z \\frac{1}{a})^{1/b}\n\na_value=300.0\nb_value=1.4\n\n#Grab reflectivity value\nrefl = csapr.fields['reflectivity'][\"data\"]\n\n#Make linear reflectivity\nlinear_refl = 10.0**(refl/10.0)\n\n#Retrieve rain rate\nrr_data = ((1.0/a_value) * linear_refl)**(1.0/b_value)\n\n#make a Py-ART field object\nrain = pyart.config.get_metadata(\"radar_estimated_rain_rate\")\nrain[\"data\"] = rr_data\n\n#Add it back onto the radar object\ncsapr.add_field('radar_estimated_rain_rate', rain, replace_existing=True)\n\n\nmydc = pyart.graph.RadarDisplay(csapr)\nmydc.plot_ppi('radar_estimated_rain_rate')\n\n","type":"content","url":"/foundations/pyart/radars-with-arm#now-lets-look-at-c-sapr","position":13},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in this Project Pythia Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1},{"hierarchy":{"lvl1":"Summer School Projects"},"type":"lvl1","url":"/projects/readme","position":0},{"hierarchy":{"lvl1":"Summer School Projects"},"content":"ARM regularly holds open science summer schools, which offer students an opportunity to learn about open source tools, work with ARM data, and develop their own workflows, aiming to answer a set of scientific questions. Previous events are listed below, with this chapter including the fully reproducible workflows.","type":"content","url":"/projects/readme","position":1},{"hierarchy":{"lvl1":"Summer School Projects","lvl2":"2024 ARM Open Science Summer School"},"type":"lvl2","url":"/projects/readme#id-2024-arm-open-science-summer-school","position":2},{"hierarchy":{"lvl1":"Summer School Projects","lvl2":"2024 ARM Open Science Summer School"},"content":"Main Landing Page\n\nGithub Repository\n\nProject Cookbooks","type":"content","url":"/projects/readme#id-2024-arm-open-science-summer-school","position":3},{"hierarchy":{"lvl1":"Summer School Projects","lvl2":"2025 CAPE-k Student Workshop"},"type":"lvl2","url":"/projects/readme#id-2025-cape-k-student-workshop","position":4},{"hierarchy":{"lvl1":"Summer School Projects","lvl2":"2025 CAPE-k Student Workshop"},"content":"Main Landing Page\n\nGithub Repository\n\nProject Cookbooks","type":"content","url":"/projects/readme#id-2025-cape-k-student-workshop","position":5},{"hierarchy":{"lvl1":"Summer School Projects","lvl2":"2025 BNF Summer School"},"type":"lvl2","url":"/projects/readme#id-2025-bnf-summer-school","position":6},{"hierarchy":{"lvl1":"Summer School Projects","lvl2":"2025 BNF Summer School"},"content":"Main Landing Page\n\nGithub Repository\n\nProject Cookbooks","type":"content","url":"/projects/readme#id-2025-bnf-summer-school","position":7},{"hierarchy":{"lvl1":"Cold Pool Analysis from BNF XSACR"},"type":"lvl1","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-radar-analysis","position":0},{"hierarchy":{"lvl1":"Cold Pool Analysis from BNF XSACR"},"content":"","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-radar-analysis","position":1},{"hierarchy":{"lvl1":"Cold Pool Analysis from BNF XSACR","lvl2":"Imports"},"type":"lvl2","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-radar-analysis#imports","position":2},{"hierarchy":{"lvl1":"Cold Pool Analysis from BNF XSACR","lvl2":"Imports"},"content":"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pyart\nfrom netCDF4 import Dataset\nimport xarray as xr\nimport glob\nimport datetime\nimport pandas as pd\nimport matplotlib.dates as mdates\nimport os\nimport math\nimport calendar\n\n\n","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-radar-analysis#imports","position":3},{"hierarchy":{"lvl1":"Cold Pool Analysis from BNF XSACR","lvl2":"Plot a Column Vertical Profile (CVP)"},"type":"lvl2","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-radar-analysis#plot-a-column-vertical-profile-cvp","position":4},{"hierarchy":{"lvl1":"Cold Pool Analysis from BNF XSACR","lvl2":"Plot a Column Vertical Profile (CVP)"},"content":"\n\ndef find_nearest(array, value):\n    array = np.asarray(array)\n    idx = (np.abs(array - value)).argmin()\n    return idx, array[idx]\n\n\ndef calculate_elevation_angle_array(height: np.ndarray, range_: np.ndarray) -> np.ndarray:\n    \"\"\"Returns an array of elevation angles in degrees.\"\"\"\n    return np.degrees(np.arctan2(height, range_))\n\ndef plot_qvp_5variables(qvp_dbzs,qvp_vels,qvp_wths,qvp_zdrs,qvp_rhos,dtimes, hgt,el, case,htop,qvp_dir):\n\n\n    \n    \n    # # Ensure dtimes is np.array of datetime\n    # if isinstance(dtimes, list):\n    #     dtimes = np.array(dtimes)\n    \n    # # Fix dimensions for pcolormesh\n    # if dtimes.ndim == 1:\n    #     dtimes = np.tile(dtimes, (new_dbzs.shape[0], 1))\n    \n    # # Check datetime format\n    # assert np.issubdtype(dtimes.dtype, np.datetime64) or isinstance(dtimes[0, 0], datetime.datetime)\n    \n    # # Ensure start_time and end_time are datetime\n    # if isinstance(start_time, str):\n    #     start_time = datetime.datetime.fromisoformat(start_time)\n    # if isinstance(end_time, str):\n    #     end_time = datetime.datetime.fromisoformat(end_time)\n    \n    # Transpose and convert to arrays\n    new_dbzs = np.array(qvp_dbzs).T\n    new_zdrs = np.array(qvp_zdrs).T\n    new_rhos = np.array(qvp_rhos).T\n    new_vels = np.array(qvp_vels).T\n    new_wths = np.array(qvp_wths).T\n    \n    # Apply RhoHV mask\n    mask = new_rhos < 0.2\n    new_dbzs[mask] = np.nan\n    new_zdrs[mask] = np.nan\n    new_rhos[mask] = np.nan\n    new_vels[mask] = np.nan\n    new_wths[mask] = np.nan\n    \n    # Setup plot\n    ytop = htop\n    fig, axes = plt.subplots(5, 1, sharex=True, figsize=(8, 15))\n    fig.subplots_adjust(hspace=0.3)\n    \n    # Plot Reflectivity\n    #pcm = axes[0].pcolormesh(dtimes, hgt / 1e3, new_dbzs, vmin=-40, vmax=40, cmap='HomeyerRainbow')\n    pcm = axes[0].pcolormesh(dtimes, hgt / 1e3, new_dbzs, vmin=-40, vmax=40, cmap='ChaseSpectral')\n    fig.colorbar(pcm, ax=axes[0], label='[dBZ]')\n    axes[0].set_ylim(0, ytop)\n    axes[0].set_title('Reflectivity')\n    axes[0].set_ylabel('height [km]')\n    \n    # Plot Velocity\n    pcm = axes[1].pcolormesh(dtimes, hgt / 1e3, new_vels, vmin=-5, vmax=5, cmap='Spectral_r')\n    fig.colorbar(pcm, ax=axes[1], label='[m/s]')\n    axes[1].set_ylim(0, ytop)\n    axes[1].set_title('Vd')\n    axes[1].set_ylabel('height [km]')\n    \n    # Plot Width\n    pcm = axes[2].pcolormesh(dtimes, hgt / 1e3, new_wths, vmin=0, vmax=3, cmap='Spectral_r')\n    fig.colorbar(pcm, ax=axes[2], label='[m/s]')\n    axes[2].set_ylim(0, ytop)\n    axes[2].set_title('Width')\n    axes[2].set_ylabel('height [km]')\n    \n    # Plot ZDR\n    #pcm = axes[3].pcolormesh(dtimes, hgt / 1e3, new_zdrs, vmin=-2, vmax=4, cmap='Spectral_r')\n    pcm = axes[3].pcolormesh(dtimes, hgt / 1e3, new_zdrs, vmin=-2, vmax=4, cmap='ChaseSpectral')\n    fig.colorbar(pcm, ax=axes[3], label='[dB]')\n    axes[3].set_ylim(0, ytop)\n    axes[3].set_title('ZDR')\n    axes[3].set_ylabel('height [km]')\n    \n    # Plot RhoHV\n    pcm = axes[4].pcolormesh(dtimes, hgt / 1e3, new_rhos, vmin=0, vmax=1, cmap='Spectral_r')\n    fig.colorbar(pcm, ax=axes[4])\n    axes[4].set_ylim(0, ytop)\n    axes[4].set_title('RhoHV')\n    axes[4].set_ylabel('height [km]')\n    axes[4].set_xlabel('Time [UTC] on ' + str(case))\n    # axes[4].set_xlim([start_time, end_time])\n    axes[4].xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\n    \n    # axes[4].set_xlim([dtimes.min(), dtimes.max()])\n    # axes[4].xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\n    # Add main title\n    plt.suptitle(f'BNF XSACR QVPs at {el} deg for {case}', y=0.95, fontsize=15)\n    \n    # Optional save\n     \n    #save_gif = qvp_dir + f'bnf_xsacr_qvp_{el}deg_{case}.png'\n    #save_gif = qvp_dir + f'bnf_xsacr_qvp_{el}deg_{case}htop_{htop}.png'\n    #plt.savefig(save_gif , dpi=400, bbox_inches=\"tight\")\n    plt.show()\n\n\n \nqvp_dir =  '/data/home/mdeng/data/bnf/qvp/xsacr/' \n#os.makedirs(qvp_dir, exist_ok=True)\n\n#dir = '/data/datastream/bnf/bnfxsacrcfrS4.a1/'\n#afile =  dir + 'bnfxsacrcfrS4.a1.20250514.225456.nc'\n\ndir = \"data/project/ARM_Summer_School_2025/radar/xsacr/*\" \n#afile =  dir + 'bnfxsacrcfrS4.a1.202505.225456.nc'\n\n\n#el = 9\nel = 16\n\n#azimuth range for a CVP\naz1 = 200\naz2 = 240\n\nyr = \"2025\"\nmonth = '05'\nday = '10'\ndate_join = f\"{yr}-{month}-{day}\"\ncase = yr + month + day\n\nfiles = sorted(glob.glob('/data/project/ARM_Summer_School_2025/radar/xsacr/bnfxsacrcfrS4.a1.'+case+'*'))\n#files = sorted(glob.glob('/data/datastream/bnf/bnfkasacrcfrS4.a1/bnfkasacrcfrS4.a1.'+case+'*'))\n\nnfiles = len(files)\n\nqvp_dbzs = []\nqvp_zdrs = []\nqvp_rhos = []\nqvp_vels = []\nqvp_wths = []\ndtimes = []\n\n\n\nfor file in files:\n    rad = pyart.io.read(file)\n    #print(file)\n\n    \n    if rad.scan_type == 'ppi':\n       \n\n        #find azimuths for XSACR file\n        azmth = rad.azimuth['data']\n        \n        #Make this into the same shape as our radar field data\n        azmth_square = np.repeat(np.expand_dims(azmth, 1), len(rad.range['data']), axis=1)\n        rad.add_field_like('reflectivity', 'azsq', azmth_square)\n \n        #Make a gate filter\n        mygf = gatefilter = pyart.correct.GateFilter(rad)\n        \n        #filter on aziumth, az1 to az2 degrees\n        mygf.exclude_outside('azsq', az1,az2) \n\n\n        \n        #qvp = pyart.retrieve.quasi_vertical_profile(rad, desired_angle=el)\n        qvp = pyart.retrieve.quasi_vertical_profile(rad, desired_angle=el, gatefilter= mygf)\n        rng = qvp['range']\n        hgt = qvp['height']\n\n        angle = calculate_elevation_angle_array(hgt, rng)\n        angle_mean = np.mean(angle)\n        d_angle  = np.abs(angle_mean - el)\n        if  d_angle  < 1:\n          \n            qdbz = qvp['reflectivity']\n            #qdbz = qvp['attenuation_corrected_reflectivity_h'] # for csapr\n            qvel = qvp['mean_doppler_velocity']\n            qwth = qvp['spectral_width']\n            \n            qzdr = qvp['differential_reflectivity']\n            qrho = qvp['copol_correlation_coeff']\n\n            rng0 = qvp['range']\n            hgt0 = qvp['height']\n\n        \n            qvp_dbzs.append(qdbz)\n            qvp_zdrs.append(qzdr)\n            qvp_rhos.append(qrho)\n            qvp_vels.append(qvel)\n            qvp_wths.append(qwth)\n    \n            #date = os.path.basename(files[i])[18:-3]\n            date = os.path.basename(file)[18:-3]\n            dto = datetime.datetime.strptime(date, '%Y%m%d.%H%M%S')\n            dtimes.append(dto)\n            \n            #print ('done with ' + file)\n\n\nrng_corr = rng*np.tan(np.deg2rad(el))\n# Define the time limits \nstart_time = np.datetime64(date_join+\"T00:00:00\")\nend_time = np.datetime64(date_join+\"T18:59:59\")\nhtop = 10\nplot_qvp_5variables(qvp_dbzs,qvp_vels,qvp_wths,qvp_zdrs,qvp_rhos,dtimes, hgt0,el, case,htop, qvp_dir)\nhtop = 2\nplot_qvp_5variables(qvp_dbzs,qvp_vels,qvp_wths,qvp_zdrs,qvp_rhos,dtimes, hgt0,el, case,htop, qvp_dir)\n\n\n","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-radar-analysis#plot-a-column-vertical-profile-cvp","position":5},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis"},"type":"lvl1","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series","position":0},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis"},"content":"import act\nimport pyart\nimport metpy\nfrom metpy.units import units\nimport numpy as np\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\nimport glob\n\n","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series","position":1},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"May 20 Event"},"type":"lvl2","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#may-20-event","position":2},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"May 20 Event"},"content":"\n\n# this is pulling individual May 20 C-SAPR2 radar data\ncsacr = \"/data/project/ARM_Summer_School_2025/bnf/bnfcsapr2cfrS3.a1/bnfcsapr2cfrS3.a1.20250520.233012.nc\"\nds_csacr = xr.open_dataset(csacr)\nds_csacr\n\nbelow is radiosonde data, but I’m not sure I need it anymore\n\n# # pull in met data using ACT\n# # Set your username and token here!\n# username = 'abchui'\n# token = '3279f3ac6800743d'\n\n# # Set the datastream and start/enddates\n# datastream = 'bnfsondewnpnM1.b1'\n# startdate = '2025-05-20T23:00:00'\n# enddate = '2025-05-20T23:59:59'\n\n# # Use ACT to easily download the data.  Watch for the data citation!  Show some support\n# # for ARM's instrument experts and cite their data if you use it in a publication\n# result_sonde = act.discovery.download_arm_data(username, token, datastream, startdate, enddate)\n\n# sonde = pyart.io.read_arm_sonde(\"/data/project/ARM_Summer_School_2025/bnf/bnfsondewnpnM1.b1/bnfsondewnpnM1.b1.20250520.233000.cdf\")\n\npull MET data and then MAWS data for the dewpoint temperature (MET doesn’t have dewpoint) in order to calculate theta-e using metpy\n\n# pull in met data using ACT\n# Set your username and token here!\nusername = 'abchui'\ntoken = '3279f3ac6800743d'\n\n# Set the datastream and start/enddates\ndatastream = 'bnfmetM1.b1'\nstartdate = '2025-05-20'\nenddate = '2025-05-21T23:59:59' #notice can give date and time or leave it blank (like with start date)\n\n# Use ACT to easily download the data.  Watch for the data citation!  Show some support\n# for ARM's instrument experts and cite their data if you use it in a publication\nresult_met = act.discovery.download_arm_data(username, token, datastream, startdate, enddate)\nds_met = act.io.read_arm_netcdf(result_met)\nds_met\n\ncalculate theta-e, a good indicator for a cold pool\n\n# thetae = metpy.calc.equivalent_potential_temperature(ds_met.atmos_pressure, ds_met.temp_mean, ds_met.dewpoint)\n\n# # Create a plotting display object with 2 plots - do I want \n# display = act.plotting.TimeSeriesDisplay(ds_met, figsize=(15, 10), subplot_shape=(2,))\n\n# # Plot up the MET btemperature and precipitation\n# display.plot('temp_mean', subplot_index=(1,))\n# ax2 = display.axes[1].twinx() #copies the x axis onto both plots\n# ax2.plot(ds_met.time, ds_met.tbrg_precip_total, color='orange')\n\n# # Plot up a day/night background\n# display.day_night_background(subplot_index=(1,))\n\n# plt.show()\n\n\n\n","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#may-20-event","position":3},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"March 15"},"type":"lvl2","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#march-15","position":4},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"March 15"},"content":"\n\n# C-SACR data\ncsacr = sorted(glob.glob(\"/data/project/ARM_Summer_School_2025/bnf/bnfcsapr2cfrS3.a1/bnfcsapr2cfrS3.a1.20250315.233012.nc\"))\n\n","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#march-15","position":5},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"May 1"},"type":"lvl2","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#may-1","position":6},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"May 1"},"content":"\n\npull kazr2 general mode data. Can use ACT for this because KAZR (RHI type) radar is not super huge file. The cone type ones (like SACR) are very large files and so would prefer to just pull individual files for those.\n\n# Set your username and token here!\nusername = 'abchui'\ntoken = '3279f3ac6800743d'\n\n# Set the datastream and start/enddates\ndatastream = 'bnfkazr2cfrgeM1.a1'\nstartdate = '2025-05-01'\nenddate = '2025-05-01T23:59:59' #notice can give date and time or leave it blank (like with start date)\n\n# Use ACT to easily download the data.  Watch for the data citation!  Show some support\n# for ARM's instrument experts and cite their data if you use it in a publication\nresult_kazr2 = act.discovery.download_arm_data(username, token, datastream, startdate, enddate)\nds_kazr2 = act.io.read_arm_netcdf(result_kazr2)\n\npull MET data and then MAWS data for the dewpoint temperature (MET doesn’t have dewpoint) in order to calculate theta-e using metpy\n\n# pull in met data using ACT\n# Set your username and token here!\nusername = 'abchui'\ntoken = '3279f3ac6800743d'\n\n# Set the datastream and start/enddates\ndatastream = 'bnfmetM1.b1'\nstartdate = '2025-05-01'\nenddate = '2025-05-01T23:59:59' #notice can give date and time or leave it blank (like with start date)\n\n# Use ACT to easily download the data.  Watch for the data citation!  Show some support\n# for ARM's instrument experts and cite their data if you use it in a publication\nresult_met = act.discovery.download_arm_data(username, token, datastream, startdate, enddate)\nds_met = act.io.read_arm_netcdf(result_met)\nds_met\n\ndownload Radar Wind Profiler (rwp) data for wind average\n\n# pull in met data using ACT\n# Set your username and token here!\nusername = 'abchui'\ntoken = '3279f3ac6800743d'\n\n# Set the datastream and start/enddates\ndatastream = 'bnf915rwpwindavgM1.a1'\nstartdate = '2025-05-01'\nenddate = '2025-05-01T23:59:59' #notice can give date and time or leave it blank (like with start date)\n\n# Use ACT to easily download the data.  Watch for the data citation!  Show some support\n# for ARM's instrument experts and cite their data if you use it in a publication\nresult_rwp = act.discovery.download_arm_data(username, token, datastream, startdate, enddate)\nds_rwp = act.io.read_arm_netcdf(result_rwp)\nds_rwp\n\ncalculate theta-e, a good indicator of cold pool\n\n# two ways to calculate theta-e: 1) pull maws data dewpoint temp and combine time or 2) calculate dewpoint temp from RH in the met data\n# method 2) is better because method 1) will cause loss of resolution\n\n# 1) to calculate theta-e, need met and maws data but by looking at the time from above you can see the time is slightly off, both are 1 min but maws if at 4 sec into the minute\n# ds_combined = xr.merge([ds_met.resample(time='1min').nearest(), ds_maws.resample(time='1min').nearest()], compat='override')\n# thetae = metpy.calc.equivalent_potential_temperature(ds_combined.atmos_pressure, ds_combined.temp_mean, ds_combined.atmospheric_dew_point)\n\n# 2) \ndewpt_temp = metpy.calc.dewpoint_from_relative_humidity(ds_met.temp_mean, ds_met.rh_mean)\nthetaeK = metpy.calc.equivalent_potential_temperature(ds_met.atmos_pressure, ds_met.temp_mean, dewpt_temp)\nthetaeC = thetaeK - 273.15*units.kelvin\n\nplot the KAZR RHI with the thetae? Or at least the mean temp and the wind barbs from rwp\n\n# Create a plotting display object with 3 plots - do I want \ndisplay = act.plotting.TimeSeriesDisplay({'KAZR2': ds_kazr2, 'MET': ds_met, 'RWP' : ds_rwp}, figsize=(15, 15), subplot_shape=(3,))\n\n# top (first) subplot (index of 0)\ndisplay.plot('reflectivity', dsname='KAZR2', subplot_index=(0,))\n\n# middle (second) subplot (index of 1)\n# Plot up the MET temperature and theta-e (calculated from met mean temp and RH)\ndisplay.plot('temp_mean', dsname='MET', subplot_index=(1,))\nax2 = display.axes[1].twinx() #copies the x axis onto both plots\nax2.plot(ds_met.time, thetaeC, color='orange')\nax2.set_ylabel('Equivalent Potential Temperature (degC)')\n\n# bottom (third) subplot (index of 2)\n# display.plot_barbs_from_spd_dir('wind_speed', num_barbs_x=20), dsname=\"RWP\", subplot_index=(2,1))\n\n# Plot up a day/night background\ndisplay.day_night_background(dsname='MET', subplot_index=(1,))\n\nplt.show()\n\n","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#may-1","position":7},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"May 12"},"type":"lvl2","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#may-12","position":8},{"hierarchy":{"lvl1":"Coldpool and Downdraft Analysis","lvl2":"May 12"},"content":"\n\ncsacr = sorted(glob.glob(\"/data/project/ARM_Summer_School_2025/bnf/bnfcsapr2cfrS3.a1/bnfcsapr2cfrS3.a1.20250512.233012.nc\"))","type":"content","url":"/projects/bnf-2025/bnf-deep-convection/coldpool-time-series#may-12","position":9}]}